{"version":3,"sources":["api/index.js","components/Feature.js","components/Loading.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Searchable","props","searchTerm","searchValue","setIsLoading","setSearchResults","className","href","onClick","event","preventDefault","results","console","error","Feature","featuredResult","id","title","dated","images","description","culture","style","dimensions","people","department","division","contact","creditline","map","person","idx","key","displayname","Loading","Preview","setFeaturedResult","searchResults","info","fetchPage","pageUrl","disabled","prev","next","record","index","log","primaryimageurl","src","alt","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","centuries","classifications","catch","onSubmit","htmlFor","type","placeholder","onChange","target","length","name","Title","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"oMAKaA,EAAW,oCACXC,EAAM,8CAKZ,SAAeC,EAAtB,oC,4CAAO,WAAiDC,EAAMC,GAAvD,iBAAAC,EAAA,+EAEoBC,MAAM,GAAD,OAAKN,EAAL,mBAA0BC,EAA1B,YAAmCE,EAAnC,YAA6CI,UAAUH,EAAMI,MAAM,KAAKC,KAAK,QAFtG,cAEGC,EAFH,gBAGgBA,EAASC,OAHzB,cAGGC,EAHH,yBAKIA,GALJ,wG,sBAcA,SAAeC,EAAtB,kC,4CAAO,WAAwCC,GAAxC,iBAAAT,EAAA,+EAEoBC,MAAMQ,GAF1B,cAEGJ,EAFH,gBAGgBA,EAASC,OAHzB,cAGGC,EAHH,yBAKIA,GALJ,wG,sBAgBA,SAAeG,EAAtB,kC,4CAAO,uCAAAV,EAAA,6DACLW,EADK,EACLA,QACAC,EAFK,EAELA,eACAC,EAHK,EAGLA,YAEMJ,EALD,UAKWd,EALX,mBAKgCC,EALhC,2BAKwDgB,EALxD,oBAMHD,EANG,oBAMkBE,GANlB,kBASoBZ,MAAMQ,GAT1B,cASGJ,EATH,gBAUgBA,EAASC,OAVzB,cAUGC,EAVH,yBAYIA,GAZJ,wG,sBAqBA,SAAeO,IAAtB,+B,4CAAO,kCAAAd,EAAA,0DACDe,aAAaC,QAAQ,aADpB,yCAEIC,KAAKC,MAAMH,aAAaC,QAAQ,eAFpC,cAKCP,EALD,UAKWd,EALX,oBAKiCC,EALjC,kDAQoBK,MAAMQ,GAR1B,cAQGJ,EARH,gBASgBA,EAASC,OATzB,cASGC,EATH,OAUGY,EAAUZ,EAAKY,QAErBJ,aAAaK,QAAQ,YAAaH,KAAKI,UAAUF,IAZ9C,kBAcIA,GAdJ,wG,sBAuBA,SAAeG,IAAtB,+B,4CAAO,kCAAAtB,EAAA,0DACDe,aAAaC,QAAQ,mBADpB,yCAEIC,KAAKC,MAAMH,aAAaC,QAAQ,qBAFpC,cAKCP,EALD,UAKWd,EALX,2BAKwCC,EALxC,yCAQoBK,MAAMQ,GAR1B,cAQGJ,EARH,gBASgBA,EAASC,OATzB,cASGC,EATH,OAUGY,EAAUZ,EAAKY,QAErBJ,aAAaK,QAAQ,kBAAmBH,KAAKI,UAAUF,IAZpD,kBAcIA,GAdJ,wG,sBCtDP,IAAMI,EAAa,SAACC,GAAW,IAGvBC,EAIAD,EAJAC,WACAC,EAGAF,EAHAE,YACAC,EAEAH,EAFAG,aACAC,EACAJ,EADAI,iBAGJ,OAAO,0BAAMC,UAAU,WACnB,uBAAGC,KAAK,IAAIC,QAAO,uCAAE,WAAOC,GAAP,eAAAhC,EAAA,6DACjBgC,EAAMC,iBACNN,GAAa,GAFI,kBAKS9B,EAAkC4B,EAAYC,GALvD,OAKPQ,EALO,OAMbN,EAAiBM,GANJ,gDAQbC,QAAQC,MAAR,MARa,yBAUbT,GAAa,GAVA,4EAAF,uDAAnB,IAYKD,EAZL,OA2MOW,EAxJC,SAACb,GAAW,IAEhBc,EAAoDd,EAApDc,eAAoDd,EAApCI,iBAAoCJ,EAAlBG,aAG1C,IAAIW,EACA,OAAO,0BAAMC,GAAG,YANG,MAyBnBD,GAAkB,GAflBE,EAVmB,EAUnBA,MACAC,EAXmB,EAWnBA,MACAC,EAZmB,EAYnBA,OAEAC,EAdmB,EAcnBA,YACAC,EAfmB,EAenBA,QACAC,EAhBmB,EAgBnBA,MAGAC,EAnBmB,EAmBnBA,WACAC,EApBmB,EAoBnBA,OACAC,EArBmB,EAqBnBA,WACAC,EAtBmB,EAsBnBA,SACAC,EAvBmB,EAuBnBA,QACAC,EAxBmB,EAwBnBA,WAGJ,OAAO,0BAAMZ,GAAG,WAEZ,yBAAKV,UAAU,kBACX,gCACI,gCAAMW,GADV,IAEI,gCAAMC,EAAN,MAEJ,6BAASZ,UAAU,SAIXc,EACI,kBAAC,WAAD,KACI,0BAAMd,UAAU,SAAhB,eACA,0BAAMA,UAAU,WAAWc,IAE7B,KAINC,EACI,kBAAC,WAAD,KACI,0BAAMf,UAAU,SAAhB,WACA,kBAAC,EAAD,eAAYJ,WAAW,UAAUC,YAAakB,GAAapB,KAE7D,KAMNuB,EACAA,EAAOK,KAAI,SAACC,EAAQC,GAAT,OACR,kBAAC,WAAD,CAAUC,IAAKD,GACV,0BAAMzB,UAAU,SAAhB,UACA,kBAAC,EAAD,eAAYJ,WAAW,SAASC,YAAa2B,EAAOG,aAAiBhC,QAGvE,KAGNqB,EACA,kBAAC,WAAD,KACA,0BAAMhB,UAAU,SAAhB,SACA,kBAAC,EAAD,eAAYJ,WAAW,QAAQC,YAAakB,GAAapB,KAE3D,KAIGsB,EACD,kBAAC,WAAD,KACA,0BAAMjB,UAAU,SAAhB,cACA,kBAAC,EAAD,eAAYJ,WAAW,aAAaC,YAAakB,GAAapB,KAEhE,KAIGwB,EACD,kBAAC,WAAD,KACA,0BAAMnB,UAAU,SAAhB,cACA,kBAAC,EAAD,eAAYJ,WAAW,aAAaC,YAAakB,GAAapB,KAEhE,KAIEyB,EACA,kBAAC,WAAD,KACA,0BAAMpB,UAAU,SAAhB,YACA,kBAAC,EAAD,eAAYJ,WAAW,WAAWC,YAAakB,GAAapB,KAE9D,KAKE0B,EACA,kBAAC,WAAD,KACA,0BAAMrB,UAAU,SAAhB,WACA,kBAAC,EAAD,eAAYJ,WAAW,UAAUC,YAAakB,GAAapB,KAE7D,KAKE2B,EACA,kBAAC,WAAD,KACA,0BAAMtB,UAAU,SAAhB,cACA,kBAAC,EAAD,eAAYJ,WAAW,aAAaC,YAAakB,GAAapB,KAEhE,KAIEkB,EACAA,EAAOU,KAAI,SAACV,EAAQY,GAAT,OACR,kBAAC,WAAD,CAAUC,IAAKD,GACV,0BAAMzB,UAAU,SAAhB,UACA,kBAAC,EAAD,eAAYJ,WAAW,SAASC,YAAagB,EAAOc,aAAiBhC,QAGvE,MASd,6BAASK,UAAU,cCvNZ4B,EARF,WACb,OACE,yBAAKlB,GAAG,WACN,wBAAIV,UAAU,WAAd,kBCgFS6B,EA7ED,SAAClC,GAAW,IACjBI,EAAqDJ,EAArDI,iBAAkB+B,EAAmCnC,EAAnCmC,kBAAmBhC,EAAgBH,EAAhBG,aADrB,EAECH,EAAMoC,cAAvBC,EAFgB,EAEhBA,KAFgB,EAEV1C,QAFU,SAcR2C,EAdQ,8EAcvB,WAAyBC,GAAzB,eAAA/D,EAAA,6DACE2B,GAAa,GADf,kBAI0BnB,EAAyBuD,GAJnD,OAIU7B,EAJV,OAKIN,EAAiBM,GALrB,gDAOIC,QAAQC,MAAR,MAPJ,yBASIT,GAAa,GATjB,6EAduB,sBA2BvB,OAAO,2BAAOY,GAAG,WACf,4BAAQV,UAAU,cAEhB,4BACEmC,UAAUH,EAAKI,KACfpC,UAAU,WACVE,QAAU,kBAAM+B,EAAUD,EAAKI,QAHjC,YAKA,4BACED,UAAUH,EAAKK,KACfrC,UAAU,OACVE,QAAU,kBAAM+B,EAAUD,EAAKK,QAHjC,SAKF,6BAASrC,UAAU,WASfL,EAAMoC,cAAczC,QAAQiC,KAAK,SAACe,EAAQC,GACzC,OAAO,yBACNb,IAAMa,EACNvC,UAAU,iBACVE,QAAS,SAACC,GACRA,EAAMC,iBACN0B,EAAkBQ,GAClBhC,QAAQkC,IAAIF,KAKZA,EAAOG,gBAAkB,yBAAKC,IAAMJ,EAAOG,gBAAkBE,IAAML,EAAOxB,cAAmB,KAI7FwB,EAAO3B,MAAQ,4BAAM2B,EAAO3B,OAAe,mDC+E1CiC,EApJA,SAACjD,GAAU,IAUhBG,EAAmCH,EAAnCG,aAAcC,EAAqBJ,EAArBI,iBAVE,EAyBc8C,mBAAS,IAzBvB,mBAyBjBC,EAzBiB,KAyBJC,EAzBI,OA0B4BF,mBAAS,IA1BrC,mBA0BjBG,EA1BiB,KA0BGC,EA1BH,OA2BcJ,mBAAS,IA3BvB,mBA2BjB7D,EA3BiB,KA2BJkE,EA3BI,OA4BML,mBAAS,OA5Bf,mBA4BjB/D,EA5BiB,KA4BRqE,EA5BQ,OA6BoBN,mBAAS,OA7B7B,mBA6BjB9D,EA7BiB,KA6BDqE,EA7BC,KAyExB,OAjCAC,qBAAU,WAIRC,QAAQC,IAAI,CAACtE,IAAqBQ,MAC/B+D,MAAK,YAAmC,IAAD,mBAAhCC,EAAgC,KAArBC,EAAqB,KACtCX,EAAeU,GACfR,EAAsBS,MAEvBC,MAAMrD,QAAQC,SAGhB,IAqBK,0BAAMG,GAAG,SAASkD,SAAQ,uCAAE,WAAOzD,GAAP,eAAAhC,EAAA,6DAClCgC,EAAMC,iBACNN,GAAa,GAFqB,kBAKVjB,EAAkB,CAAEC,UAASC,iBAAgBC,gBALnC,OAK1BqB,EAL0B,OAMhCN,EAAiBM,GANe,gDAQhCC,QAAQC,QARwB,yBAUhCT,GAAa,GAVmB,4EAAF,uDAahC,kCACE,2BAAO+D,QAAQ,YAAf,SACA,2BACEnD,GAAG,WACHoD,KAAK,OACLC,YAAY,oBACZ7F,MAAOc,EACPgF,SAAU,SAAA7D,GAAK,OAAI+C,EAAe/C,EAAM8D,OAAO/F,WAEnD,kCACE,2BAAO2F,QAAQ,yBAAf,kBAAsD,0BAAM7D,UAAU,wBAAhB,IAAyCgD,EAAmBkB,OAA5D,MACtD,4BACEC,KAAK,iBACLzD,GAAG,wBACHxC,MAAOa,EACPiF,SAAU,SAAA7D,GAAK,OAAIiD,EAAkBjD,EAAM8D,OAAO/F,SAClD,4BAAQA,MAAM,OAAd,OASE8E,EAAmBzB,KAAI,SAACxC,EAAgB0C,GACtC,OAAO,4BAAQC,IAAG,UAAKD,EAAL,YAAY1C,EAAeoF,MAAQjG,MAAOa,EAAeoF,MAAOpF,EAAeoF,WAMzG,kCACE,2BAAON,QAAQ,kBAAf,WAAwC,0BAAM7D,UAAU,iBAAhB,IAAkC8C,EAAYoB,OAA9C,MACxC,4BACEC,KAAK,UACLzD,GAAG,iBACHxC,MAAOY,EACPkF,SAAU,SAAA7D,GAAK,OAAIgD,EAAWhD,EAAM8D,OAAO/F,SAC3C,4BAAQA,MAAM,OAAd,OAUE4E,EAAYvB,KAAI,SAACzC,EAAS2C,GAAV,OACd,4BAAQC,IAAG,UAAKD,EAAL,YAAY3C,EAAQqF,MAAQjG,MAAOY,EAAQqF,MACnDrF,EAAQqF,WAMnB,4CCzIaC,EAbD,WAEd,OAAS,yBAAK1D,GAAG,SACf,iDAGA,qFCUE2D,EAAM,WAAO,IAAD,EAE0BxB,mBAAU,CAACb,KAAM,GAAI1C,QAAS,KAFxD,mBAETyC,EAFS,KAEMhC,EAFN,OAI4B8C,mBAAS,MAJrC,mBAITpC,EAJS,KAIOqB,EAJP,OAMkBe,oBAAS,GAN3B,mBAMTyB,EANS,KAMExE,EANF,KAQhB,OAAO,yBAAKE,UAAU,OAapB,kBAAC,EAAD,MACA,kBAAC,EAAD,CAAQF,aAAgBA,EAAcC,iBAAoBA,IAG1D,kBAAC,EAAD,CAASgC,cAAiBA,EAAejC,aAAgBA,EAAcC,iBAAoBA,EAAkB+B,kBAAqBA,IAElI,kBAAC,EAAD,CAASrB,eAAkBA,EAAgBX,aAAgBA,EAAcC,iBAAoBA,IAE5FuE,EAAY,kBAAC,EAAD,MAAc,OAQ9BC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,S","file":"static/js/main.d30f33d1.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=03cebca8-3432-4059-ad33-63f54e02de0e';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { Fragment } from 'react';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = (props) => {\n\n    const {\n        searchTerm,\n        searchValue,\n        setIsLoading,\n        setSearchResults\n    } = props\n\n    return <span className=\"content\">\n        <a href=\"#\" onClick={async (event) => {\n            event.preventDefault()\n            setIsLoading(true)\n\n            try {\n                const results = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue)\n                setSearchResults(results)\n            } catch (error) {\n                console.error(error)\n            } finally {\n                setIsLoading(false)\n            }\n        }}> {searchValue} </a>\n    </span>\n\n}\n\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n * \n * <main id=\"feature\"></main>\n * \n * And like this when one is:\n * \n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n * \n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n * technique, medium, dimensions, people, department, division, contact, creditline\n * \n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n * \n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n * \n * This component should be exported as default.\n */\nconst Feature = (props) => {\n\n    const { featuredResult, setSearchResults, setIsLoading }  = props // this will contain all the facts needed\n    // console.log(featuredResult)\n\n    if(!featuredResult){\n        return <main id=\"feature\"></main>\n    }\n\n    const {\n        title,\n        dated,\n        images, // THIS IS AN ARRAY\n        //primaryimageurl, // only use if making image or something clickable\n        description,\n        culture, // SEARCHABLE\n        style,\n        //technique, // SEARCHABLE\n       // medium, // SEARCHABLE\n        dimensions,\n        people, // SEARCHABLE -- person.displayname\n        department,\n        division,\n        contact,\n        creditline,\n    } = featuredResult || {}\n\n    return <main id=\"feature\">\n        \n        <div className=\"object-feature\">\n            <header>\n                <h3> {title}</h3> {/*<h3> {featuredResult.title}</h3>*/}\n                <h4> {dated} </h4>\n            </header>\n            <section className=\"facts\">\n                {/* <span className=\"title\">FACT NAME</span>\n                <span className=\"content\">FACT VALUE</span> */}\n                {\n                    description ?\n                        <Fragment>\n                            <span className=\"title\">Description</span>\n                            <span className=\"content\">{description}</span>\n                        </Fragment>\n                        : null\n                }\n                \n                {\n                    culture ?\n                        <Fragment>\n                            <span className=\"title\">Culture</span>\n                            <Searchable searchTerm=\"culture\" searchValue={culture} {...props} />\n                        </Fragment> \n                        : null\n                }\n                \n                {/* HW: ADD THE OTHERS HERE */}\n                \n                {\n                    people ?\n                    people.map((person, idx) => \n                       <Fragment key={idx} >\n                            <span className=\"title\">Person</span>\n                            <Searchable searchTerm=\"person\" searchValue={person.displayname} {...props} />\n                        </Fragment> \n                        )\n                        : null\n                }\n                {\n                    style ?\n                    <Fragment>\n                    <span className=\"title\">Style</span>\n                    <Searchable searchTerm=\"style\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                }\n\n                {\n                     dimensions ?\n                    <Fragment>\n                    <span className=\"title\">Dimensions</span>\n                    <Searchable searchTerm=\"dimensions\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                }\n\n                {\n                     department ?\n                    <Fragment>\n                    <span className=\"title\">Department</span>\n                    <Searchable searchTerm=\"department\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                }\n\n                {\n                    division ?\n                    <Fragment>\n                    <span className=\"title\">Division</span>\n                    <Searchable searchTerm=\"division\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                    \n                }\n   \n              {\n                    contact ?\n                    <Fragment>\n                    <span className=\"title\">Contact</span>\n                    <Searchable searchTerm=\"contact\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                    \n                }\n\n                {\n                    creditline ?\n                    <Fragment>\n                    <span className=\"title\">creditline</span>\n                    <Searchable searchTerm=\"creditline\" searchValue={culture} {...props} />\n                </Fragment> \n                : null\n                }\n\n                {\n                    images ?\n                    images.map((images, idx) =>\n                       <Fragment key={idx} >\n                            <span className=\"title\">images</span>\n                            <Searchable searchTerm=\"images\" searchValue={images.displayname} {...props} />\n                        </Fragment>\n                        )\n                        : null\n                }\n\n\n\n\n\n\n            </section>\n            <section className=\"photos\">\n                {/* <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE /> \n                    remeber to map over the images array from props\n                    use image.baseimageurl for image URL\n                    use image.creditline or image.description for alt \n                    if you want to you can make image clickable with a tag and use primaryimageurl -- Will need a fragment\n                */}\n            </section>\n        </div>\n    </main>\n}\n\nexport default Feature;","import React from 'react';\n\n/**\n * Create and export a component called Loading which uses this static HTML template:\n * \n * <div id=\"loading\">\n *   <h2 className=\"message\">Searching...</h2>\n * </div>\n */\n const Loading = () => {\n    return (\n      <div id=\"loading\">\n        <h2 className=\"message\">Searching...</h2>\n      </div>\n    )\n    }\n    \n    export default Loading;","// import React from 'react';\nimport React from 'react';\n// /**\n//  * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n//  * which are query urls.\n//  */// import { fetchQueryResultsFromURL } from '../api';\n// const Preview = (props) => {\n//   /**\n//    * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n//    * and also destructure info and records from props.searchResults\n//    * \n//    * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n//    */\nimport { fetchQueryResultsFromURL } from '../api';\n\nconst Preview = (props) => {\n    const {setSearchResults, setFeaturedResult, setIsLoading} = props;\n    const {info, records} = props.searchResults;\n    /**\n     * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n     * and also destructure info and records from props.searchResults\n     * \n     * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n     */\n    /**\n     * Don't touch this function, it's good to go.\n     * \n     * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n     */\n    async function fetchPage(pageUrl) {\n      setIsLoading(true);\n  \n      try {\n        const results = await fetchQueryResultsFromURL(pageUrl);\n        setSearchResults(results);\n      } catch (error) {\n        console.error(error);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n  \n    return <aside id=\"preview\">\n      <header className=\"pagination\">\n        {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n        <button \n          disabled={info.prev ? false: true } \n          className=\"previous\"\n          onClick ={() => fetchPage(info.prev)}>Previous</button>\n        {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n        <button\n          disabled={info.next ? false: true } \n          className=\"next\"\n          onClick={ () => fetchPage(info.next)}>Next</button>\n      </header>\n      <section className=\"results\">\n\n      {/* centuryList.map((century, idx) =>\n            <option key={`${idx}:${century.name}`} value={century.name}>\n              {century.name}\n            </option>\n          )\n        } */}\n\n        { props.searchResults.records.map ((record, index) => { \n           return <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => {\n              event.preventDefault()\n              setFeaturedResult(record)\n              console.log(record)\n              // prevent the default\n              // set the featured result to be this records, using setFeaturedResult\n            }}>\n            { \n              record.primaryimageurl ? <img src={ record.primaryimageurl } alt={ record.description } /> : null\n              // if the records.primaryimageurl exists, show this: <img src={ records.primaryimageurl } alt={ records.description } />, otherwise show nothing \n            }\n            {\n              record.title ? <h3>{ record.title }</h3> : <h3>MISSING INFO</h3>\n              // if the records.title exists, add this: <h3>{ records.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n            }\n          </div>\n        }\n        )}\n       \n                  \n      </section>\n    </aside>\n  }\n  \n  export default Preview;","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport {\n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n  // the props we passed in is setIsLoading and setSearchResults\n  // remember props is an object\n  // console.log(\"in Search component\")\n  // console.log(props) -> {setIsLoading: ƒ, setSearchResults: ƒ}\n\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n\n  // props.setIsLoading(...)\n  // we are matching the name when deconstructing\n  const { setIsLoading, setSearchResults } = props\n\n  // we can now do setIsLoading()\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * \n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n\n  const [centuryList, setCenturyList] = useState([])\n  const [classificationList, setClassificationList] = useState([])\n  const [queryString, setQueryString] = useState(\"\")\n  const [century, setCentury] = useState(\"any\")\n  const [classification, setClassification] = useState(\"any\")\n\n\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    // fetchAllCenturies()\n    // fetchAllClassifications()\n\n    Promise.all([fetchAllCenturies(), fetchAllClassifications()])\n      .then(([centuries, classifications]) => {\n        setCenturyList(centuries)\n        setClassificationList(classifications)\n      })\n      .catch(console.error)\n\n\n  }, []);\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * HINT: Look at your state\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n\n\n  return (<form id=\"search\" onSubmit={async (event) => {\n    event.preventDefault()\n    setIsLoading(true)\n\n    try {\n      const results = await fetchQueryResults({ century, classification, queryString })\n      setSearchResults(results)\n    } catch (error) {\n      console.error()\n    } finally {\n      setIsLoading(false)\n    }\n  }}>\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input\n        id=\"keywords\"\n        type=\"text\"\n        placeholder=\"enter keywords...\"\n        value={queryString}\n        onChange={event => setQueryString(event.target.value)} />\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({classificationList.length})</span></label>\n      <select\n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification}\n        onChange={event => setClassification(event.target.value)}>\n        <option value=\"any\">Any</option>\n        {\n          //   {\n          //     \"objectcount\": 5623,\n          //     \"id\": 30,\n          //     \"lastupdate\": \"2015-11-22T03:17:45-0500\",\n          //     \"name\": \"Sculpture\",\n          //     \"classificationid\": 30\n          // }\n          classificationList.map((classification, idx) => {\n            return <option key={`${idx}:${classification.name}`} value={classification.name}>{classification.name}</option>\n            // <option value=\"Sculpture\">Sculpture</option>\n          })\n        }\n      </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({centuryList.length})</span></label>\n      <select\n        name=\"century\"\n        id=\"select-century\"\n        value={century}\n        onChange={event => setCentury(event.target.value)}>\n        <option value=\"any\">Any</option>\n        \n        {/* map over the centuryList, return an <option /> */\n          //   {\n          //     \"id\": 37525374,\n          //     \"objectcount\": 28,\n          //     \"lastupdate\": \"2015-11-22T03:17:52-0500\",\n          //     \"temporalorder\": 3,\n          //     \"name\": \"6th millennium BCE\"\n          // }\n          centuryList.map((century, idx) =>\n            <option key={`${idx}:${century.name}`} value={century.name}>\n              {century.name}\n            </option>\n          )\n        }\n      </select>\n    </fieldset>\n    <button>SEARCH</button>\n  </form>\n  )\n}\n\nexport default Search;","import React from 'react';\n\n\n//  * Create/export a component called Title which uses this static HTML as the template:\n  const Title = () => {\n\n  return ( <div id=\"title\">\n    <h1>\n      The Art Collector\n    </h1>\n    <h5>\n      Search the Harvard Art Museums' Private Collections\n    </h5>\n  </div>)\n\n  }\n\n  export default Title;","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n//These imports won't work until you fix ./components/index.js\nimport {\n  //Feature,\n  Loading,\n  Preview,\n  Search,\n  Feature,\n  Title\n} from './components';\n/**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\nconst App = () => {\n  \n  const [searchResults, setSearchResults] = useState ({info: {}, records: []});\n\n  const [featuredResult, setFeaturedResult] = useState(null);\n  \n  const [isLoading, setIsLoading] = useState(false);\n\n  return <div className=\"app\">\n\n  {/* /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    \n    <Title />\n    <Search setIsLoading = {setIsLoading} setSearchResults = {setSearchResults}/> \n    \n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview searchResults = {searchResults} setIsLoading = {setIsLoading} setSearchResults = {setSearchResults} setFeaturedResult = {setFeaturedResult} />\n    \n    <Feature featuredResult = {featuredResult} setIsLoading = {setIsLoading} setSearchResults = {setSearchResults} /> \n    \n    {isLoading ? <Loading /> : null} \n  </div>\n}\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\n ReactDOM.render(<App />, document.getElementById('app'));"],"sourceRoot":""}